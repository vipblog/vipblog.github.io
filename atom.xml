<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://vipblog.github.io</id>
    <title>ShineEternal 的小站</title>
    <updated>2020-06-09T11:57:55.552Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://vipblog.github.io"/>
    <link rel="self" href="https://vipblog.github.io/atom.xml"/>
    <subtitle>一个由 ShineEternal 搭建的小站！

&lt;br/&gt;

如有任何问题请联系 QQ：3197301325</subtitle>
    <logo>https://vipblog.github.io/images/avatar.png</logo>
    <icon>https://vipblog.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ShineEternal 的小站</rights>
    <entry>
        <title type="html"><![CDATA[CF1365D Solve The Maze 题解]]></title>
        <id>https://vipblog.github.io/o5EvDo1aI/</id>
        <link href="https://vipblog.github.io/o5EvDo1aI/">
        </link>
        <updated>2020-06-09T11:54:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">description：</h2>
<p>求能否在一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的矩阵中设置一些墙使得所有好人都能到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(n,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，而所有坏人都不能。</p>
<h2 id="solution">solution：</h2>
<p>我们只需要判断每个好人能否在不经过坏人的情况下到达终点即可（如果在途中与坏人相邻则同样不能到达）。</p>
<p>有一个剪枝就是将连在一起的好人仅保留一个而其他都看做空地，可减少 dfs 的次数。</p>
<h2 id="code">code：</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
char a[55][55];
int sx[5]={0,-1,1,0,0};
int sy[5]={0,0,0,-1,1};
int vis[55][55];
int n,m;
int dfs(int xx,int yy)
{
	for(int i=1;i&lt;=4;i++)
	{
		int x=xx+sx[i];
		int y=yy+sy[i];
		if(a[x][y]=='B')
		{
			return 0;
		}
	}
	if(xx==n&amp;&amp;yy==m)return 1;
	for(int i=1;i&lt;=4;i++)
	{
		int x=xx+sx[i];
		int y=yy+sy[i];
		if(vis[x][y]==0&amp;&amp;(a[x][y]=='G'||a[x][y]=='.'))
		{
			vis[x][y]=1;
			if(dfs(x,y))
			{
				vis[x][y]=0;
				return 1;
			}
		}
	}
	return 0;
}
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		for(int i=1;i&lt;=n;i++)
		{
			for(int j=1;j&lt;=m;j++)
			{
				cin&gt;&gt;a[i][j];
			}
		}
		int flag=0;
		for(int i=1;i&lt;=n;i++)
		{
			for(int j=1;j&lt;=m;j++)
			{
				if(a[i][j]=='G')
				{
					if(a[i][j-1]=='G'||a[i][j+1]=='G'||a[i-1][j]=='G'||a[i+1][j]=='G')
					{
						if(a[i][j-1]!='B'&amp;&amp;a[i][j+1]!='B'&amp;&amp;a[i-1][j]!='B'&amp;&amp;a[i+1][j]!='B')
						{
							a[i][j]='.';
							continue;
						}
					}
					memset(vis,0,sizeof(vis));
					
					if(dfs(i,j)==0)
					{
						printf(&quot;No\n&quot;);
						flag=1;
						break;
					}
				}
				
			}
			if(flag==1)
				break;
		}
		if(flag==0)
		{
			printf(&quot;Yes\n&quot;);
		}
	}
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1365C Rotation Matching 题解]]></title>
        <id>https://vipblog.github.io/oPwX6bNsk/</id>
        <link href="https://vipblog.github.io/oPwX6bNsk/">
        </link>
        <updated>2020-06-08T13:30:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">description：</h2>
<ul>
<li>
<p>给定两个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\sim n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的排列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i,b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
</li>
<li>
<p>你可以对任意一个排列进行若干次长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的 <strong>循环右移或左移</strong>；这里的循环移动指每个元素依次向左或右移动 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个，如果移出边界的元素再折回到排列的头或尾。</p>
</li>
<li>
<p>你需要求出在移动过后最多有多少个对应的位置使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i=b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1\le n\le 2\times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\le a_i,b_i\le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p>
</li>
<li>
<p>translate by @<a href="https://www.luogu.com.cn/user/45475">ShineEternal</a>。</p>
</li>
</ul>
<h2 id="solution">solution：</h2>
<p>我们直接在众多种移动方法中保留任意一种其实就行了。</p>
<p>我们对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 中的每个元素，记录其与对应的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 中相等的元素所相差的距离，众数即为答案。</p>
<h2 id="code">code：</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
int abs(int x)
{
	if(x&lt;0)return -x;
	return x;
}
int max(int x,int y)
{
	if(x&gt;y)return x;
	return y;
}
int a[200005],b[200005],dis[200005],mp0[200005],mp[200005];
int main()
{
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		mp0[a[i]]=i;
	}
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;b[i]);
		mp[b[i]]=i;
	}
	for(int i=1;i&lt;=n;i++)
	{
		dis[(n+mp0[i]-mp[i])%n]++;
	}
	int ans=0;
	for(int i=1;i&lt;=n;i++)
	{
		ans=max(ans,dis[i]);
	}
	if(n==1)printf(&quot;1\n&quot;);
	else
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1365B Trouble Sort 题解]]></title>
        <id>https://vipblog.github.io/sal5L5T03/</id>
        <link href="https://vipblog.github.io/sal5L5T03/">
        </link>
        <updated>2020-06-08T12:24:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">description：</h2>
<ul>
<li>
<p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和每个元素的属性 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
</li>
<li>
<p>一次操作定义为一对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mi mathvariant="normal">≠</mi><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">b_i\neq b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 时，交换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i,a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。（属性也随之交换）</p>
</li>
<li>
<p>你需要求出这个序列能否由若干次（可以为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>）操作后得到一个不降序列。</p>
</li>
<li>
<p><strong>输入有多组数据</strong>。数据组数不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">1\le n\le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1\le a_i\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>∈</mo><mo>{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">b_i\in \{0,1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>。</p>
</li>
<li>
<p>translate by @<a href="https://www.luogu.com.cn/user/45475">ShineEternal</a>。</p>
</li>
</ul>
<h2 id="solution">solution：</h2>
<p>这道题可以观察到一个十分有趣的属性：只要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 都存在，那么这个序列一定能由一些操作后得到不降序列。</p>
<p>否则如果序列最开始已经是不降序列了，也是 <code>Yes</code>。</p>
<p>其余情况就是 <code>No</code> 了。</p>
<h2 id="code">code：</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
int a[505],b[505];
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int n;
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;a[i]);
		}
		int flag0=0,flag1=0;
		for(int i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;b[i]);
			if(b[i]==0)
			{
				flag0=1;
			}
			if(b[i]==1)
			{
				flag1=1;
			}
		}
		if(flag0==1&amp;&amp;flag1==1)
		{
			printf(&quot;Yes\n&quot;);
			continue;
		}
		flag1=0;
		for(int i=2;i&lt;=n;i++)
		{
			if(a[i-1]&gt;a[i])
			{
				printf(&quot;No\n&quot;);
				flag1=1;
				break;
			}
		}
		if(flag1==0)
		printf(&quot;Yes\n&quot;);
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1365A Matrix Game 题解]]></title>
        <id>https://vipblog.github.io/uvPUTnSVv/</id>
        <link href="https://vipblog.github.io/uvPUTnSVv/">
        </link>
        <updated>2020-06-08T11:07:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">description：</h2>
<ul>
<li>
<p>给定一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的矩阵，有一些格子是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，有一些格子是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p>
</li>
<li>
<p>Ashish 和 Vivek 轮流往矩阵中放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。某个格子可以放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 当且仅当这个格子所在的行和列没有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
</li>
<li>
<p>最后无处放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的玩家就输了。你需要输出赢家的姓名。</p>
</li>
<li>
<p>多组数据，数据组数不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">1\le n,m\le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>。</p>
</li>
<li>
<p>translate by @<a href="https://www.luogu.com.cn/user/45475">ShineEternal</a>。</p>
</li>
</ul>
<h2 id="solution">solution：</h2>
<p>这道题目 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span></span></span></span> 的范围较小，所以直接模拟即可。</p>
<p>由于先后顺序并没有影响，故按顺序添加就好。</p>
<p>在添加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的时候记录下当前是谁走的。可以使用 <code>TUrn=(TUrn+1)%2;</code> 类似的标记器。</p>
<hr>
<p>update soon：</p>
<p>突然发现其实取出空行和空列的最小值判断奇偶性就行了。</p>
<h2 id="code">code：</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int a[55][55];
int x[55],y[55];
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int n,m;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		memset(x,0,sizeof(x));
		memset(y,0,sizeof(y));
		for(int i=1;i&lt;=n;i++)
		{
			for(int j=1;j&lt;=m;j++)
			{
				scanf(&quot;%d&quot;,&amp;a[i][j]);
				if(a[i][j]==1)
				{
					x[i]=1;
					y[j]=1;
				}
			}
		}
		int TUrn=1;
		for(int i=1;i&lt;=n;i++)
		{
			if(x[i]==0)
			{
				int flag=0;
				//x[i]=1;
				for(int j=1;j&lt;=m;j++)
				{
					if(y[j]==0)
					{
						y[j]=1;
						flag=1;
						break;
					}
				}
				if(flag==1)
				{
					x[i]=1;
					TUrn=(TUrn+1)%2;
				}
			}
		}
		if(TUrn==1)
		{
			printf(&quot;Vivek\n&quot;);
		}
		else
		{
			printf(&quot;Ashish\n&quot;);
		}
	}
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1363E Tree Shuffling 题解]]></title>
        <id>https://vipblog.github.io/F7QMFSJu-/</id>
        <link href="https://vipblog.github.io/F7QMFSJu-/">
        </link>
        <updated>2020-06-07T09:37:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">description：</h2>
<figure data-type="image" tabindex="1"><img src="https://vipblog.github.io/post-images/1591522797207.png" alt="" loading="lazy"></figure>
<h2 id="solution">solution：</h2>
<p>我们观察到这棵树的一个性质：一个节点可以完成某修改操作，那么它的祖先也可以完成。</p>
<p>所以我们可以先优化题目的策略：遇到祖先节点的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 值比子节点小的时候直接把子节点的值更新成这个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 即可。（效果上是相等的）</p>
<p>优化完了之后直接 dp 即可。</p>
<p>我们设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[u][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 节点的子树中初始状态为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 且准备改为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的节点的个数。 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[u][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 同理。</p>
<p>那么对于子树的更改我们就可以一步一步记录到祖先节点上，最终累加判断就行了。</p>
<hr>
<p>盘点自己的一个很小但找了很久的 bug：</p>
<p>u 和 i 在键盘上离得太近导致在 i 的循环内错打为 u。</p>
<h2 id="code">code：</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
//#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
struct ben
{
	long long x,y,z;
}a[200005];
vector&lt;long long&gt;e[200005];
long long ans;
long long dp[200005][2];
long long min(long long x,long long y)
{
	if(x&gt;y)return y;
	return x;
}
void dfs(long long u,long long fa,long long sp)
{
	if(a[u].y!=a[u].z)
	{
		dp[u][a[u].y]=1;
	}
	for(int i=0;i&lt;e[u].size();i++)
	{
		int v=e[u][i];
		if(v==fa)continue;
		dfs(v,u,min(a[u].x,sp));
		dp[u][0]+=dp[v][0];
		dp[u][1]+=dp[v][1];
	}
	sp=min(sp,a[u].x);
	long long sum=min(dp[u][0],dp[u][1]);
	ans+=2*sum*sp;
	dp[u][0]-=sum;
	dp[u][1]-=sum;
}
int main()
{
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].z);
	}
	int u,v;
	for(int i=1;i&lt;n;i++)
	{
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	
	dfs(1,-1,0x3f3f3f3f);
	if(dp[1][0]||dp[1][1])ans=-1;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UVA12372 Packing for Holiday 题解]]></title>
        <id>https://vipblog.github.io/ttjzCkQpc/</id>
        <link href="https://vipblog.github.io/ttjzCkQpc/">
        </link>
        <updated>2020-06-06T09:52:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">description：</h2>
<p>判断三个数是否都大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>，如果都大于则输出 <code>bad</code>，否则输出 <code>good</code>。</p>
<h2 id="solution">solution：</h2>
<p>如题目描述。</p>
<h2 id="code">code：</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	int cnt=0;
	while(T--)
	{
		cnt++;
		int a,b,c;
		scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
		if(a&lt;=20&amp;&amp;b&lt;=20&amp;&amp;c&lt;=20)
		{
			printf(&quot;Case %d: good\n&quot;,cnt);
		}
		else
		{
			printf(&quot;Case %d: bad\n&quot;,cnt);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1363C Game On Leaves 题解]]></title>
        <id>https://vipblog.github.io/yPNLqcRv7/</id>
        <link href="https://vipblog.github.io/yPNLqcRv7/">
        </link>
        <updated>2020-06-06T09:07:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">description：</h2>
<p>给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个节点的无根树。</p>
<p>两名选手轮流操作，每次可以选择一个叶节点并删除它以及所有和它相连的边。叶节点指度数不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的节点。删除节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的选手胜利。</p>
<p>你需要判断先手是否有必胜策略。</p>
<h2 id="solution">solution：</h2>
<p>首先观察到这道题的一个特判点：如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 刚开始就在叶子节点上，那么先手必然胜利。</p>
<p>注意不要忘了一个小 feature：这棵树可能只有一个节点，所以特判时不能只判度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>那么如果不在呢？</p>
<p>这时我们可以知道，与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 节点相连的边数一定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\geq 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>。所以由于两个人都实行最优策略，所以到了仅剩下两条与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 相连的边时就只会开始拆其他的点。</p>
<p>那么答案就只与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的奇偶性有关了。判断一下即可。</p>
<h2 id="code">code：</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int p[1005];
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int a,b;
		int n,x;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;x);
		memset(p,0,sizeof(p));
		for(int i=1;i&lt;n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			p[a]++;
			p[b]++;
		}
		if(p[x]&lt;=1)
		{
			printf(&quot;Ayush\n&quot;);
		}
		else
		{
			if(n%2==1)
			{
				printf(&quot;Ashish\n&quot;);
			}
			else
			{
				printf(&quot;Ayush\n&quot;);
			}
		}
	}
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1363B Subsequence Hate 题解]]></title>
        <id>https://vipblog.github.io/pRCDOERxL/</id>
        <link href="https://vipblog.github.io/pRCDOERxL/">
        </link>
        <updated>2020-06-06T05:00:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">description：</h2>
<p>将一个 <code>01</code> 串变为不含 <code>010</code> 和 <code>101</code> 子串的字符串。</p>
<h2 id="solution">solution：</h2>
<p>仔细分析一下性质就可以发现，我们大部分情况下需要将整个字符串都变成 <code>0</code> 或 <code>1</code>。</p>
<p>但是如果整个字符串中只有一个 <code>0/1</code>  在字符串的两端，那么情况也是合法的。</p>
<p>所以我们只需要在变字符串的时候每次都更新一下两种数字的最小值就行了。</p>
<p>其最小值就意为最小可以获取的步数。</p>
<h2 id="code">code：</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		char s[1005];
		int cnt1=0,cnt2=0;
		scanf(&quot;%s&quot;,s);
		for(int i=0;i&lt;strlen(s);i++)
		{
			if(s[i]=='0')
			cnt1++;
			else
			cnt2++;
		}
		int ans=1000000;
		for(int i=0;i&lt;strlen(s);i++)
		{
			ans=min(ans,min(cnt1,cnt2));
			if(s[i]=='0')
			{
				cnt1--;
				cnt2++;
			}
			else
			{
				cnt1++;
				cnt2--;
			}
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[量子力学杂谈]]></title>
        <id>https://vipblog.github.io/liang-zi-li-xue-za-tan/</id>
        <link href="https://vipblog.github.io/liang-zi-li-xue-za-tan/">
        </link>
        <updated>2020-05-20T11:09:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="part0引言"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi mathvariant="normal">.</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">part.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord">0</span></span></span></span>：引言🤠：</h2>
<p>薛定谔的猫，即为量子力学中最经典的一个例子。本篇日报就来讲解一下本实验以及量子力学相关内容</p>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3UuY29tLmNuL3VwbG9hZC9pbWFnZV9ob3N0aW5nLzNlMG1sb2hoLnBuZw?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<h2 id="part1实验介绍"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi mathvariant="normal">.</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">part.1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord">1</span></span></span></span>：实验介绍：</h2>
<h3 id="准备物品主要">准备物品（主要）：</h3>
<ul>
<li>
<p>一只活着的猫。</p>
</li>
<li>
<p>少量的镭：镭的衰变（会放出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>粒子），但是只知道它的半衰期（即原子核衰变一半所需要的时间），也就相当于我们只知道了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span>，而开始衰变的时间是不确定的</p>
</li>
<li>
<p>氰化物：就是个用来毒猫的，装在一个瓶子里，瓶子被砸碎会导致猫被毒死</p>
</li>
<li>
<p>锤子：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>粒子会触发电子机关，使锤子砸向装有氰化物的瓶子（保证砸碎）</p>
</li>
<li>
<p>密闭容器：保证一旦释放毒气猫必死</p>
</li>
</ul>
<h3 id="开始试验">开始试验：</h3>
<p>将以上物品都装入密闭容器中（组装可见上图），镭衰变存在几率，也就是说猫的死也有一定的几率（根据物品栏的注释，相信这不难明白是为什么）</p>
<p>而在量子力学中</p>
<blockquote>
<p>放射性的镭处于衰变和未衰变两种状态的叠加</p>
</blockquote>
<h4 id="这就导致了">这就导致了：</h4>
<p>那只猫处于活猫和死猫两种状态的叠加！！！</p>
<figure data-type="image" tabindex="2"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3UuY29tLmNuL3VwbG9hZC9pbWFnZV9ob3N0aW5nL2k1ZXd1ZjdsLnBuZw?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<p><s>死去活来，强颜欢笑</s></p>
<p>但是生活中的正常生物都不会有这种情况。</p>
<p>由此，这个实验被称为<strong>量子力学的起源</strong></p>
<h2 id="part2-量子力学"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi mathvariant="normal">.</mi><mn>2</mn><mo>:</mo></mrow><annotation encoding="application/x-tex">part.2:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span> 量子力学</h2>
<h3 id="概述">概述：</h3>
<blockquote>
<p>量子力学（Quantum Mechanics），为物理学理论，是研究物质世界微观粒子运动规律的物理学分支，主要研究原子、分子、凝聚态物质，以及原子核和基本粒子的结构、性质的基础理论。</p>
</blockquote>
<p><strong>它与相对论一起构成现代物理学的理论基础。</strong><s>现代物理学两大烧脑基础</s></p>
<p>量子力学不仅是现代物理学的基础理论之一，而且在<strong>化学</strong>等学科和许多近代技术中得到广泛应用。</p>
<h3 id="起因">起因：</h3>
<blockquote>
<p>19世纪末，人们发现旧有的经典理论无法解释微观系统，于是经由物理学家的努力，在20世纪初创立量子力学，解释了这些现象。</p>
</blockquote>
<h3 id="一些有趣的例子">一些有趣的例子</h3>
<p>当然，量子力学博大精深，如果认真学的话会<s>吐血</s>深感其中的奥秘，所以以下介绍几个经典例子，可以更通俗的了解量子力学，而不会第一次就看到复杂的公式而打消兴趣。</p>
<h3 id="eg1黑箱中的电子">e.g.1:黑箱中的电子</h3>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3UuY29tLmNuL3VwbG9hZC9pbWFnZV9ob3N0aW5nL2s1bGZjeGhzLnBuZw?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<p>假设在一个不透明的箱子中有一个电子，如图</p>
<p>但是其实是看不到它的具体位置。</p>
<ul>
<li>这时，我们根据<strong>哥本哈根</strong>的解释——在盒子中任何一处找到电子的机会是均等的。</li>
</ul>
<p>但是好像是个人都会这么想。</p>
<p>换一种说法，就是伴随着电子的概率波均匀地分布在盒子中。</p>
<hr>
<p><strong>什么是概率波？</strong></p>
<blockquote>
<p>概率波 ，就是物质波，指空间中某点某时刻可能出现的几率。</p>
</blockquote>
<ul>
<li>
<p>自由电子：波函数就是行波，就是说它有可能出现在空间中任何一点，每点几率相等。</p>
</li>
<li>
<p>如果被束缚在氢原子里，并且处于基态：它出现在空间任何一点都有可能，但是在<strong>波尔半径处几率最大</strong>。</p>
</li>
</ul>
<p>举个形象的例子：你现在虽然坐在电脑前，但是也是有可能在火星上，不过只是概率特别小而不可能被观测到。</p>
<p><strong>可以看做这个点未来可能移动的轨迹</strong></p>
<hr>
<p>现在，假设一块木板掉落在了盒子中间。</p>
<p>此时黑箱被均匀的分割成两部分。</p>
<p>根据常识，我们知道电子不是在这边就是在那边（电子很小不考虑切割）</p>
<p>但是，<strong>哥本哈根</strong>又说了：概率波仍然均匀的分布在两端。</p>
<p>也就是说在黑箱任意一侧都有相等的概率找到电子。</p>
<p>但是，一旦一个人向里面看一眼（且看到了电子的位置），那么波函数就会发生坍塌。</p>
<hr>
<p><strong>波函数坍塌？</strong></p>
<h4 id="我们可以将这个形象的认为是这个更靠谱">我们可以将这个形象的认为是（这个更靠谱）：</h4>
<ul>
<li>
<p>一个人向空中抛了一个骰子</p>
</li>
<li>
<p>骰子还未落地时，不知道点数的几率，这时就是一个波函数。</p>
</li>
<li>
<p>骰子一落地就可以发现最终的结果，这时，就相当于波函数“坍塌”了。</p>
</li>
</ul>
<h4 id="也可以这么理解">也可以这么理解：</h4>
<p>好几个共同发展的概率波，一旦其中一个被观测到（被验证），其他几个就会下降（被观测的概率波为1了），此时就是坍塌。</p>
<hr>
<p>这时的电子就不再是以“概率”的形式体现，而是真实存在的了。</p>
<p>此时，如果关闭箱子，停止观测，由于我们已经确认过电子的位置且有隔板，那么此时这对概率波就会立即填满电子所在的这一次。</p>
<ul>
<li>前面说了一个火星和电脑的比方，这里类比一下，还有极小的概率使得电子位于另一侧甚至在黑箱外，但是由于过小就被忽略了。</li>
</ul>
<h4 id="到这里实验大概结束了">到这里，实验大概结束了。</h4>
<p>但是，一位物理学家鲍尔戴维斯又换了一种更简明的方法阐述这个实验。</p>
<p>假设在隔板两侧分别有一个电子“幽灵”</p>
<figure data-type="image" tabindex="4"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3UuY29tLmNuL3VwbG9hZC9pbWFnZV9ob3N0aW5nL2ttc3BldzZpLnBuZw?x-oss-process=image/format,png" alt="" loading="lazy"></figure>
<p>此时，只要有一个观察者看到<strong>任意一个</strong>，那么他就会变为真实的电子，<strong>同时</strong>另一个会消失。</p>
<hr>
<h4 id="哥本哈根">哥本哈根：</h4>
<p>注意到上文中大量提到了哥本哈根，于是简介一下。</p>
<p><s>因为在网上搜除了是个地名就是影片</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AT5158 [AGC037A] Dividing a String 题解]]></title>
        <id>https://vipblog.github.io/at5158-agc037a-dividing-a-string-ti-jie/</id>
        <link href="https://vipblog.github.io/at5158-agc037a-dividing-a-string-ti-jie/">
        </link>
        <updated>2020-05-20T11:07:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">😇description</h2>
<ul>
<li>
<p>给定一个字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，请你找出一个最大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，使得将这个字符串划分成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 段后能够保证相邻的两段不相同。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1\le |S| \le 2\times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，且保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 串内均为小写字母。</p>
</li>
<li>
<p>translate by @<a href="https://www.luogu.com.cn/user/45475">ShineEternal</a>。</p>
</li>
</ul>
<h2 id="solution">solution</h2>
<p>我们贪心的进行划分，每次遇到一个和上一次不一样的串就可以单独提取出来一次了。</p>
<h2 id="code">code</h2>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
using namespace std;
char s[200005];
int main()
{
	int cnt=0;
	scanf(&quot;%s&quot;,&amp;s);
	int n=strlen(s);
	string a=&quot;&quot;,b=&quot;&quot;;
	for(int i=0;i&lt;n;i++)
	{
		a+=s[i];
		if(a!=b)
		{
			b=a;
			cnt++;
			a=&quot;&quot;;
		}
	}
	printf(&quot;%d\n&quot;,cnt);
	return 0;
} 
</code></pre>
]]></content>
    </entry>
</feed>